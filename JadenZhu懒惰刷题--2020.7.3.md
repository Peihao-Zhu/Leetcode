# 7月3日

今天刷题的感觉似乎又没有昨天好了，主要是前两题把我搞得心态有点炸。最简单的BFS是会的，但是其他递归和迭代的方法当时都没想到，特别是117题，以后做树相关的题目还是要注意总结，仔细观察规律。

还有最后一题的最长回文子串，dp的方式求，有点忘了需要回顾一下.

​	dp [i] [j]表示字符串第i到第j部分子串是否是回文的
$$
dp[i] [j] =\begin{cases} \ dp[i+1][j-1],s[i]=s[j] \\ false \quad\quad\quad\quad , s[i]!=s[j] \end{cases}
$$
其中，如果j-i<2 切s [i]=s[j] 可以直接对dp [i j]赋值true。

有空可以重温一下，是**LeetCode 第5题**



| 编号 | 题目                                           | 解题方法                                                     |
| ---- | ---------------------------------------------- | ------------------------------------------------------------ |
| 116  | Populating Next Right Pointers in Each Node    | 最简单就是用BFS，但是不符合题意（O(1)的空间复杂度），所以不使用队列，根据题意将root.left.next=root.right ，然后在判断root.next是否为null。如果不是，就将它的right和他next节点的left连接。 还有一种递归的方法，是深度的，不是广度的。 |
| 117  | Populating Next Right Pointers in Each Node II | 头皮发麻，这题难度明显比116高了好多。BFS的方法就不用了，一模一样。迭代的话，需要注意每一层在遍历的时候需要确保他有左孩子或者右孩子，在进行连接。然后在向下层移动的时候记录一个dummy指针每次都指向当前层的下一层的头节点前一个指针；递归构造一个函数getNextNotNullChild(root)，每次讲当前节点的孩子的next只想这个函数返回的节点 |
| 127  | Word Ladder(单词接龙)                          | 用BFS，将每个有可能的情况放入队列。优化（双向BFS，并且每次从队列小的先开始判断） |
| 130  | Surrounded Regions                             | 对边界区域使用dfs。使用并查集                                |
| 134  | Gas Station                                    | 类似于贪心算法，画个图，找到累计剩余gas的最低点，选择该点的后一个位置为起点。 |
| 131  | Palindrome Partitioning                        | 标准的回溯，优化的地方在于判断是否是回文字串部分，可以先用dp把所有情况都分析一下。 |

