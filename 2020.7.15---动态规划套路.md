# 7月15日

今天早上10点才醒，晕死.....

但是到了下午我的眼睛居然还是很困，一直想闭上，我是不是没救了....

状态不好只能少做几道题目了，太难了....



因为状态不好，所以俺今天决定好好看看别人的文章，学习一下动态规划的套路，之前自己也做过一些dp的题目但是并没有系统的掌握，往往是想到了状态转换方程就能写出，否则就gg，所以今天希望能系统的了解dp。

动态规划问题一般形式是：**求最值**

求最值，核心问题是**穷举**，动态规划的穷举存在**重叠子问题**，需要【备忘录】或【DP 表】来优化穷举过程；而且动态规划问题一定具备 **最优子结构**，最后要穷举最值需要 **状态转移方程**。

```java
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义
  
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

要符合 **最优子结构**，子问题之间必须是相互独立的！！！举个例子：

比如要求考出最高的总成绩，这个问题可以划分为几个子问题，也就是分别考出最高的语文成绩，最高的数学成绩....；考出最高的语文成绩也能划分为考出最高的 选择题，考出最高的大题目.....可以发现这些子问题之间相互是没有制约，没有限制的，是独立的，所以可以说这些子问题之间是独立的。

###  [LeetCode 322零钱兑换](https://leetcode-cn.com/problems/coin-change/)

要凑出金额11元 有1，2，5三种金额的钱

此时第一个子结构当然就是分别判断 凑出 11-1=10的最少硬币个数，凑出11-2=9的最少硬币个数，凑出11-5=6的最少硬币个数，然后还能继续不断划分子结构，因为硬币之间是没有数量限制，所以是符合最优子结构的。

本题的求解可以用一种自顶向下的形式（递归），使用备忘录来消除重叠子问题；也可以用迭代的方式自底向上求解，使用dp表消除重叠子问题。

![img](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media)



**dp数组的遍历方向**

有时候遍历是正向的，有时是反向的，有时是斜方向的，但其实只要记住两个原则就可以

- 遍历的过程中，所需的状态必须是已经计算出来的
- 遍历的终点必须是存储结果的位置



### 01背包问题：

```java
N = 3 //商品个数
W = 4//背包重量
wt = [2, 1, 3]//每个商品对应的重量
val = [4, 2, 3]//每个商品对应的价值

int 01bag(){
	//dp[i][j]表示对于前i个物品，当前背包可用容量为j
	int[][] dp=new int[N+1][W+1];
	dp[0][...]=0;
	dp[...][0]=0;
	for(int i=1;i<=N;i++){
	//j正序还是反序并没有影响，因为只和前一列有关，而前一列已经求出来了
		for(int j=W;j>=1;j--)
			{
      //背包容量不足以放下当前商品
       if(j-wt[i-1]<0){
         dp[i][j]=Math.max(dp[i-1][j]);
       }
				//这里就是判断要不要把i个物品放到背包里
				//这里wt[i-1] val[i-1]就是第i个物品的重量和价值
				dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-wt[i-1]]+val[i-1]);
			}
	}
	return dp[W];
}
```

### LeetCode 416 分割等和子集

对数组求和然后 除以2就是背包的容量，就相当于在数组中找是否能刚好填满这个背包的。

```java
 public boolean canPartition(int[] nums) {
        //类似于01背包
        int len=nums.length;
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        //如果是奇数 直接gg
        if(sum%2==1) return false;
        boolean [][]dp=new boolean[len+1][sum/2+1];
        //背包容量为0时，就相当于装满了，所以为true
        for(int i=0;i<=len;i++) dp[i][0]=true;
        for(int i=0;i<=sum/2;i++) dp[0][i]=false;
        for(int i=1;i<=len;i++){
            for(int j=1;j<=sum/2;j++){
                if(j-nums[i-1]<0){
                    dp[i][j]=dp[i-1][j];
                }
                else{
                    //第i个物品的重量是nums[i-1]
                    //使用了或逻辑表达式 ，只要有一个true，就是true
                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];
                }
            }
        }
        return dp[len][sum/2];
    }
```

也可以进行状态压缩，因为dp的第一维变量每次都新增一，所以可以去除这一维度

| 编号 | 题目                       | 解题方法                                                 |
| ---- | -------------------------- | -------------------------------------------------------- |
| 322  | Coin Change                | 上面有讲解                                               |
| 416  | Partition Equal Subset Sum | 上面有讲解                                               |
| 518  | Coin Change 2              | 完全背包，回溯法是会超时的，状态转移方程和相关细节见下文 |

### 518 零钱兑换2

```java
//dp[i][j] 表示前i个硬币，想要凑出j，有多少种凑法
int [][]dp=new int[len+1][amount+1];

dp[0][...]=0 //不用任何硬币肯定凑不出来
dp[...][0]=1 //目标金额是0，就是不用任何硬币，也算一种


//状态转移方程，如果不拿第i个硬币，就是dp[i-1][j]种可能性
 //如果拿第i个面值的硬币，有dp[i][j-coins[i-1]]种可能性 ----这里就是完全背包和01背包的区别
dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];
```

